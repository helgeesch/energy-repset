### **The Three Generalized Workflows**

Here are the three primary types of workflows that repset-v2 will support. Each uses the five core modules in a slightly different sequence and with different emphasis.

#### **Workflow 1: Generate-and-Test**

This is the classic combinatorial search approach. Its philosophy is to create many candidate solutions, evaluate each one thoroughly, and then use a clear policy to select the best.

* **Examples:** Exhaustive (brute-force) search, Genetic Algorithms.  
* **How the Modules are Used:**  
  * **SearchAlgorithm (A):** Its main role is to generate candidate subsets. This is often delegated to a CombinationGenerator (which can handle constraints like "one per season").  
  * **ObjectiveSet (F):** Used intensively. It is called to evaluate *every single candidate subset* generated by the search algorithm.  
  * **SelectionPolicy (Π):** Used at the very end. After the search is complete, it receives a full table of all candidates and their scores, and applies its rule (e.g., WeightedSum) to pick the winner.  
  * **Summary:** There is a clear, linear sequence: the SearchAlgorithm generates, the ObjectiveSet evaluates, and the Policy decides.

#### **Workflow 2: Constructive**

This approach builds a solution directly and iteratively, rather than testing pre-made combinations. It's generally much faster than the Generate-and-Test workflow.

* **Examples:** K-Medoids, K-Means, Hierarchical Clustering, Hull Clustering.  
* **How the Modules are Used:**  
  * **SearchAlgorithm (A):** This is the star of the show. It contains the entire complex logic of the method (e.g., the k-medoids algorithm). It has its own *internal objective* (e.g., minimize intra-cluster distance) that guides its construction process.  
  * **ObjectiveSet (F):** Not used *during* the search. Its role shifts to **post-hoc evaluation**. After the SearchAlgorithm has constructed a final solution, the ObjectiveSet is used to give it a standardized score. This is crucial for comparing its result against the results from other workflow types.  
  * **SelectionPolicy (Π):** **Bypassed entirely.** The constructive nature of the algorithm *is* its own policy; the final result is the direct output of the construction process, with no separate decision step needed.  
  * **Summary:** The SearchAlgorithm does all the heavy lifting to directly build a solution. The ObjectiveSet is only used for final validation.

#### **Workflow 3: Direct Optimization**

This is the most sophisticated workflow. It formulates the entire selection problem as a single, large-scale mathematical optimization problem and uses a dedicated solver to find the globally optimal solution.

* **Examples:** Mixed-Integer Linear Programming (MILP) to select periods that best reconstruct an annual duration curve.  
* **How the Modules are Used:**  
  * **SearchAlgorithm (A):** Its main job is to act as a bridge to a mathematical programming solver (e.g., Gurobi, HiGHS). It translates the user's problem into the strict mathematical language of the solver.  
  * **ObjectiveSet (F):** Its concepts (e.g., "minimize NRMSE") are translated into the formal *mathematical objective function* of the optimization model. It is deeply embedded within the SearchAlgorithm's formulation.  
  * **SelectionPolicy (Π):** **Bypassed entirely.** The solver's goal is to find the single optimal solution that minimizes the mathematical objective. The decision is inherent in the optimization process.  
  * **Summary:** The problem is handed off to a powerful external solver. The main work is in the *formulation* of the problem within the SearchAlgorithm module.